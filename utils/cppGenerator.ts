import { DeviceConfig, ButtonMapping, ActionConfig } from '../types';
import { RTC_GPIO_PINS } from '../constants';

export const generateCppCode = (device: DeviceConfig, buttons: ButtonMapping[]): string => {
  // 1. Generate Definitions for HID Keys (collect from both short and long press)
  const allActions = buttons.flatMap(b => [b.shortPress, b.longPress]);
  const uniqueKeys = Array.from(new Set(allActions.filter(a => a.mode === 'key').map(a => a.keyConfig)));
  const defineLines = uniqueKeys
    .map(k => `#define ${k.name.padEnd(20)} ${k.code}`)
    .join('\n');

  // 2. Generate Pin Constants
  const pinConstants = buttons
    .map((b, index) => `const int pinBtn${index} = ${b.pin};`)
    .join('\n');

  // 3. Helper to generate modifier byte
  const getModByte = (m: any) => {
    let val = 0;
    if (m.ctrl) val |= 0x01;  // LEFT_CTRL
    if (m.shift) val |= 0x02; // LEFT_SHIFT
    if (m.alt) val |= 0x04;   // LEFT_ALT
    if (m.gui) val |= 0x08;   // LEFT_GUI
    return `0x${val.toString(16).toUpperCase().padStart(2, '0')}`;
  };

  // 4. Text Table Generation
  // We need to collect all unique text strings and assign them an index
  const uniqueTexts = Array.from(new Set(allActions.filter(a => a.mode === 'text').map(a => a.text)));
  // Map text to index
  const textToIndex = (text: string) => uniqueTexts.indexOf(text);
  
  const textTable = uniqueTexts.map(t => `"${t}"`).join(',\n  ');

  // 5. Generate Button Structs
  const generateActionStruct = (action: ActionConfig, enabled: boolean = true) => {
    // Mode: 0=Key, 1=Text, 2=None
    if (!enabled) return `{ 2, 0, 0, -1 }`;
    
    const mode = action.mode === 'key' ? 0 : 1;
    const keyCode = action.mode === 'key' ? action.keyConfig.name : '0';
    const mods = action.mode === 'key' ? getModByte(action.modifiers) : '0';
    const txtIdx = action.mode === 'text' ? textToIndex(action.text) : -1;
    
    return `{ ${mode}, ${keyCode}, ${mods}, ${txtIdx} }`;
  };

  const buttonStructs = buttons.map((b, index) => {
    const shortAction = generateActionStruct(b.shortPress);
    const longAction = generateActionStruct(b.longPress, b.longPressEnabled);
    
    return `  { pinBtn${index}, ${shortAction}, ${longAction}, HIGH, 0, HIGH, 0, false }`;
  }).join(',\n');

  // 6. Calculate Wakeup Mask for Deep Sleep
  const rtcButtons = buttons.filter(b => RTC_GPIO_PINS.includes(b.pin));
  const wakePin = rtcButtons.length > 0 ? rtcButtons[0].pin : -1;

  return `/**
 * Generated by ESP32 BLE Keygen
 * Device: ${device.name}
 * Manufacturer: ${device.manufacturer}
 * 
 * REQUIRED LIBRARY: NimBLE-Arduino by h2zero
 */

#include <NimBLEDevice.h>
#include <NimBLEHIDDevice.h>
#include <NimBLEAdvertising.h>
#include <WiFi.h>
#include "esp_sleep.h"

// --- Configuration ---
${pinConstants}

const unsigned long debounceTime = ${device.debounceTime}; // ms
const unsigned long longPressTime = ${device.longPressDuration}; // ms
const unsigned long idleTimeout = ${device.sleepTimeout}; // ms before deep sleep

// --- HID Keycodes used in this mapping ---
${defineLines}

// --- ASCII to HID Map (Standard US Layout) ---
const uint8_t ASCII_MAP[95][2] = {
  {0, 0x2C}, {1, 0x1E}, {1, 0x34}, {1, 0x20}, {1, 0x21}, {1, 0x22}, {1, 0x24}, {0, 0x34}, // 32-39
  {1, 0x26}, {1, 0x27}, {1, 0x25}, {1, 0x2E}, {0, 0x36}, {0, 0x2D}, {0, 0x37}, {0, 0x38}, // 40-47
  {0, 0x27}, {0, 0x1E}, {0, 0x1F}, {0, 0x20}, {0, 0x21}, {0, 0x22}, {0, 0x23}, {0, 0x24}, // 48-55
  {0, 0x25}, {0, 0x26}, {1, 0x33}, {0, 0x33}, {1, 0x36}, {0, 0x2E}, {1, 0x37}, {1, 0x38}, // 56-63
  {1, 0x1F}, {1, 0x04}, {1, 0x05}, {1, 0x06}, {1, 0x07}, {1, 0x08}, {1, 0x09}, {1, 0x0A}, // 64-71
  {1, 0x0B}, {1, 0x0C}, {1, 0x0D}, {1, 0x0E}, {1, 0x0F}, {1, 0x10}, {1, 0x11}, {1, 0x12}, // 72-79
  {1, 0x13}, {1, 0x14}, {1, 0x15}, {1, 0x16}, {1, 0x17}, {1, 0x18}, {1, 0x19}, {1, 0x1A}, // 80-87
  {1, 0x1B}, {1, 0x1C}, {1, 0x1D}, {0, 0x2F}, {0, 0x31}, {0, 0x30}, {1, 0x23}, {1, 0x2D}, // 88-95
  {0, 0x35}, {0, 0x04}, {0, 0x05}, {0, 0x06}, {0, 0x07}, {0, 0x08}, {0, 0x09}, {0, 0x0A}, // 96-103
  {0, 0x0B}, {0, 0x0C}, {0, 0x0D}, {0, 0x0E}, {0, 0x0F}, {0, 0x10}, {0, 0x11}, {0, 0x12}, // 104-111
  {0, 0x13}, {0, 0x14}, {0, 0x15}, {0, 0x16}, {0, 0x17}, {0, 0x18}, {0, 0x19}, {0, 0x1A}, // 112-119
  {0, 0x1B}, {0, 0x1C}, {0, 0x1D}, {1, 0x2F}, {1, 0x31}, {1, 0x30}, {1, 0x35}              // 120-126
};

// --- Structs ---

struct ActionConfig {
  uint8_t mode;      // 0=Key, 1=Text, 2=None
  uint8_t keyCode;
  uint8_t modifiers;
  int textIndex;
};

struct Button {
  int pin;
  ActionConfig shortPress;
  ActionConfig longPress;
  
  // State Machine
  bool lastReading;             // Immediate reading from previous loop
  unsigned long lastDebounceTime; // Last time pin changed
  bool state;                   // Stable debounced state
  unsigned long pressTime;      // Time when state went LOW
  bool longPressHandled;        // Flag if long press was already executed
};

const char* textTable[] = {
  ${textTable || '""'}
};

Button buttons[] = {
${buttonStructs}
};

const int buttonCount = sizeof(buttons) / sizeof(buttons[0]);
unsigned long lastActivityTime = 0;

NimBLEHIDDevice* hid;
NimBLECharacteristic* input;

// --- Helper Functions ---

void sendReport(uint8_t modifiers, uint8_t code) {
  uint8_t report[8] = {0};
  report[0] = modifiers; // Modifier byte
  report[2] = code;      // Keycode byte
  input->setValue(report, sizeof(report));
  input->notify();
  delay(15);
  
  // Release
  memset(report, 0, sizeof(report));
  input->setValue(report, sizeof(report));
  input->notify();
}

void sendChar(char c) {
  if (c < 32 || c > 126) return; // Only support ASCII printable
  uint8_t index = c - 32;
  uint8_t mod = ASCII_MAP[index][0] ? 0x02 : 0x00; // 0x02 is Left Shift
  uint8_t key = ASCII_MAP[index][1];
  sendReport(mod, key);
  delay(15);
}

void typeText(const char* text) {
  int len = strlen(text);
  for (int i = 0; i < len; i++) {
    sendChar(text[i]);
  }
}

void executeAction(ActionConfig& action) {
  if (action.mode == 0) { // Key
    sendReport(action.modifiers, action.keyCode);
  } else if (action.mode == 1) { // Text
    if (action.textIndex >= 0) {
      typeText(textTable[action.textIndex]);
    }
  }
  // Mode 2 = None, do nothing
}

// --- Server Callbacks ---
class ServerCallbacks: public NimBLEServerCallbacks {
  void onConnect(NimBLEServer* pServer, ble_gap_conn_desc* desc) {
    Serial.print("Client connected: ");
    Serial.println(NimBLEAddress(desc->peer_ota_addr).toString().c_str());
    pServer->updateConnParams(desc->conn_handle, 6, 20, 0, 100);
  };

  void onDisconnect(NimBLEServer* pServer) {
    Serial.println("Client disconnected - restarting advertising");
    NimBLEDevice::getAdvertising()->start();
  };
};

void setup() {
  Serial.begin(115200);

  WiFi.mode(WIFI_MODE_NULL);
  WiFi.disconnect(true);

  for (int i = 0; i < buttonCount; i++) {
    pinMode(buttons[i].pin, INPUT_PULLUP);
    buttons[i].lastReading = HIGH;
    buttons[i].state = HIGH;
    buttons[i].longPressHandled = false;
  }

  NimBLEDevice::setPower(ESP_PWR_LVL_P9);
  NimBLEDevice::setSecurityAuth(true, true, true); 

  NimBLEDevice::init("${device.name}");
  NimBLEServer* pServer = NimBLEDevice::createServer();
  pServer->setCallbacks(new ServerCallbacks());
  
  hid = new NimBLEHIDDevice(pServer);
  input = hid->getInputReport(1);

  hid->setManufacturer("${device.manufacturer}");
  hid->setPnp(0x02, 0x02E5, 0xABCD, 0x0100);
  hid->setHidInfo(0x00, 0x01);

  // Standard Keyboard Report Map
  uint8_t reportMap[] = {
    0x05, 0x01, 0x09, 0x06, 0xA1, 0x01, 
    0x05, 0x07, 0x19, 0xE0, 0x29, 0xE7, 0x15, 0x00, 0x25, 0x01, 0x75, 0x01, 0x95, 0x08, 0x81, 0x02, 
    0x95, 0x01, 0x75, 0x08, 0x81, 0x01, 
    0x95, 0x06, 0x75, 0x08, 0x15, 0x00, 0x25, 0xE7, 0x05, 0x07, 0x19, 0x00, 0x29, 0xE7, 0x81, 0x00, 
    0xC0
  };
  
  hid->setReportMap(reportMap, sizeof(reportMap));
  hid->startServices();

  NimBLEAdvertising* pAdv = pServer->getAdvertising();
  pAdv->setAppearance(HID_KEYBOARD);
  pAdv->addServiceUUID(hid->getHidService()->getUUID());
  
  NimBLEAdvertisementData scanResponse;
  scanResponse.setName("${device.name}");
  pAdv->setScanResponseData(scanResponse);
  
  pAdv->start();

  Serial.println("BLE Keyboard Ready.");
  lastActivityTime = millis();
}

void loop() {
  unsigned long now = millis();
  bool activityDetected = false;

  for (int i = 0; i < buttonCount; i++) {
    bool reading = digitalRead(buttons[i].pin);

    // 1. Debounce Logic
    if (reading != buttons[i].lastReading) {
      buttons[i].lastDebounceTime = now;
      buttons[i].lastReading = reading;
      activityDetected = true;
    }

    if ((now - buttons[i].lastDebounceTime) > debounceTime) {
      // 2. State Change Detection
      if (reading != buttons[i].state) {
        buttons[i].state = reading;

        if (buttons[i].state == LOW) {
          // Pressed
          buttons[i].pressTime = now;
          buttons[i].longPressHandled = false;
        } else {
          // Released
          if (!buttons[i].longPressHandled) {
             // Short Press Action
             executeAction(buttons[i].shortPress);
          }
        }
        activityDetected = true;
      }
      
      // 3. Long Press Detection while held
      if (buttons[i].state == LOW) {
        if (!buttons[i].longPressHandled && (now - buttons[i].pressTime > longPressTime)) {
           // Check if long press is actually configured (Mode != 2)
           if (buttons[i].longPress.mode != 2) {
             executeAction(buttons[i].longPress);
             buttons[i].longPressHandled = true;
           }
        }
      }
    }
  }

  if (activityDetected) {
    lastActivityTime = now;
  }

  delay(20); 

  ${device.deepSleepEnabled ? `
  if ((now - lastActivityTime) > idleTimeout) {
     Serial.println("Entering Deep Sleep...");
     Serial.flush();
     ${wakePin !== -1 ? `esp_sleep_enable_ext0_wakeup((gpio_num_t)${wakePin}, 0);` : '// No RTC pin mapped!'}
     esp_deep_sleep_start();
  }` : ''}
}`;
};
